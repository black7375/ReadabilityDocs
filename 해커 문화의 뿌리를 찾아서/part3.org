* 해커 문화의 뿌리를 찾아서 Part 3: 해커리즘의 문화
2007년 6월 5일
:PROPERTIES:
:TOC:      this
:END:
-  [[#들어가며][들어가며]]
-  [[#하드웨어와-교감하다][하드웨어와 교감하다]]
-  [[#람다-계산법lambda-calculus][람다 계산법(Lambda Calculus)]]
-  [[#paradigms-of-artificial-intelligence-programming][Paradigms of Artificial Intelligence Programming]]

** 들어가며
누가 무언가를 아주 좋아한다고 생각해 보자. 그리고 그 일이 컴퓨터나 프로그래밍에 관한 것이라고 범위를 더 좁혀보자. 예술 또는 다른 분야의 일이나 취미라도 상관은 없다. 그리고 그 일에 지속적으로 몰입하는 사람들이 몇 명 더 있다고 하자. 여기에서 공통적인 문화가 하나 탄생한다. 일종의 하위문화(subculture)라고 할 수도 있는 이 문화는 그것이 어떤 것이건 빠져있는 사람들에게는 아주 진지한 것이다. 보는 각도에 따라 진지한 놀이처럼, 때로는 진지한 일처럼 보일 수도 있다(일과 놀이의 심리적 요소가 아주 비슷하다는 사실은 예전부터 알려져 왔었다).

만약 이 문화가 주류 문화라면 우리가 매일 열심히 일하는 세상 일이 된다(일상적인 세상 일이 아주 재미있는 경우는 흔치 않지만). 주류 세계와는 조금 다른 일이 더 재미있을 수도 있다. 비주류나 반문화적인 요소가 있는 문화가 수용되는 일도 꽤 많이 존재했다.

현재 IT 문화의 일부 역시 기묘한 하위문화로부터 출발했다. 해커리즘도 그 중 하나다. 당연히 초창기에는 컴퓨터를 만지는 사람들이 이상하게 보이거나 이단적으로 보였다. 그것도 (대기업이나 연구소 직원으로서가 아니라) 정말로 컴퓨터가 좋아 컴퓨터에 빠져든 사람들은 사회의 일반적인 시각에서 보면 분명히 이단적인 요소가 있었다.

스티븐 레비의 책 『해커 그 광기와 비밀의 기록(원제는 Hackers: Heroes of the Computer Revolution)』은 이러한 이야기를 풀어나갔다. 초창기 MIT AI 연구소를 중심으로 한 1세대 해커와 컴퓨터를 사람들에게 보급시킨 2세대 해커들의 이야기가 책의 3분의 2를 채우고 있다. 1세대 해커가 리스프(LISP) 해커와 미니컴퓨터 해커라면 빌 게이츠나 스티브 잡스 같은 문화 아이콘들은 2세대 해커에 속한다.

『해커…』라는 책이 나온 지 이미 20년 정도가 지났고 컴퓨터가 하나의 주류 문화 정도가 아니라 문명의 근간이 되면서 이런 사람들의 이야기가 수용되기 시작했다. 세월이 더 지나면 이야기를 아름답게 적을 수 있는 동화작가의 손을 거쳐 미화되어야 할지 모른다. 사람들이 기대하는 문화코드는 보통 그런 것들이고 그런 책들이 서점에서 잘 팔린다. 나중에 아이들에게 이야기해줄 때도 껄끄럽지 않을 것이다. 그러나 새로운 문화나 하위문화가 항상 주류 문화에 대해 껄끄러웠다는 점은 인정해야 한다. 이들이 메인스트림으로 변한다 해도 초기의 그 이상한 에너지와 열정은 신비로운 것이며 다른 혁명이나 문화 활동에서도 공통적으로 나타났던 일들이다.

역사적으로도 비슷한 예가 있다. 산업혁명이 초기에 당시로서는 지극히 이단적이던 유니태리언파 사람들이나 프리메이슨, 아니면 그에 못지않게 비표준적이던 사람들에 의해 시작되었다는 것을 역사책에서는 잘 다루지 않는다. 교육 배경이나 사회적 지위가 아니라 스스로의 생각에 따라 움직일 수밖에 없던 사람들은 언제나 많은 것이다. 이들을 산업기계문명의 해커라고 불러도 하나도 이상한 일이라고 할 수 없을 것이다.

컴퓨터 문화의 전부는 아니더라도 중요한 요소들이 컴퓨터에 빠져있던 사람들의 정서를 반영한다. 세속적인 일이 아니라 컴퓨터에 빠져있던 이상한 사람들의 이야기는 방송으로도 나왔다. 예전에 미국 PBS에서 크린즐리의 ‘Triumph of the Nerds’라는 프로그램을 방송한 적이 있다. 이 프로는 상당한 인기를 모았다. 주식 시장에서 IT 주식이 마구 오르던 시절이어서 이 프로그램은 사람들의 반발을 사지도 않았다. 기묘한 괴짜인 너드들이 영웅시되기 시작했다. 결국 한때 괴짜 같던 컴퓨터 문화가 중요한 무엇으로 인정받았음을 의미한다. 컴퓨터 문화라는 것은 이상한 일도 아니었으며 예전과 달리 중요하지 않다고 생각하는 사람도 별로 없다.

산업혁명의 발전이 만들어낸 변화들이 모두 밝은 측면만을 가지는 것은 아니며 러다이트 운동이나 다른 노동운동 문화를 만들어낸 것도 사실이다. 컴퓨터에 대해서도 사람들이 반드시 밝은 측면만을 바라보는 것은 아니다. 그러나 초창기에 결정적인 변화를 만들어낸 사람들은 그들만의 강렬한 에너지가 있었다. 산업혁명이나 르네상스와 같은 시절에도 분명히 어떤 사람들의 강렬한 지적인 에너지가 있었다.

물론 해커들만 이상한 것은 아니다. 그들 주위의 일상도 정상적인 것은 아니었다. 1세대 해커들이 활동한 1960년대와 1970년대의 사회 분위기를 정상으로 보기도 어렵다. 그때가 좋은 시절이었는가를 생각해 보면 당시 사회의 광기어린 면들을 지적하지 않을 수 없다. 2차 대전이 끝나고 미국과 소련이 주도하는 냉전이 최고조에 달했던 시절이다. 군부 출신 대통령 아이젠하워가 걱정스러워 할 정도로 비대해진 군산복합체가 있었고 언제라도 핵전쟁이 터질지 모른다는 불안한 생각이 사회를 지배하던 시절이었다. 그리고 방위에도 과학기술 발전이 필수적이라는 것을 알게 되면서 이들의 돈이 컴퓨터를 연구하는 분야에도 투자되었다. 소련이 인공위성을 먼저 발사하면서 갑자기 엄청난 돈이 과학 연구에 투자되었다. 당시 사회에도 약간 미쳐 보이는 요소가 없는 것은 아니었다.

고가의 장비이던 컴퓨터를 만지는 사람들도 이 자금으로부터 무관하지는 않았다. 양심을 지키기 위해 최선을 다했다 해도 그렇다. 컴퓨터를 하려면 주류 문화의 설비를 이용하지 않을 수 없었다. 당시 지배층의 아이디어와 사회 통제에 대한 집착이 실제로는 누구의 생각과 이해관계를 반영하는가에 대해 생각하지 않을 수 없다. 그리고 악의에 찬 지배와 관리에 대한 집착이 아니더라도 그 집착에 이르게 한 판단의 근거들이 옳았는지를 생각하지 않을 수 없다. “옳다와 그르다”의 경계점은 항상 애매하기 때문에 근거에 대해 생각해보지 않을 수 없는 것이다. 사회 규정이나 규범에도 언제나 버그가 꽤 많이 존재한다.

요즘 세계화와 지적 자본주의 속에서 우리의 활동에 대해 후세에 어떤 비평을 들을지는 미지수다. 자유롭게 보이는 우리의 IT 산업과 문화는 복잡한 관계의 거미줄 속에서 자유롭지 않다. 회사와 기업에서 발생하는 새로운 통제는 얼마든지 우리를 얽매고 있을 수 있다. 실제로 기업들은 생존을 위해 여러 가지 일을 해왔던 것도 사실이다. ‘옳다와 그르다’ 또는 ‘정상적이거나 묘해 보이는’ 일들도 항상 새롭게 생각해 보지 않을 수 없다.

비판의식을 갖건 비판의식을 갖지 않건 하위문화는 강렬한 관심과 집중으로 만들어지는 작은 종교집단처럼 보인다고 한다. 사람들이 빠져있는 관심의 원은 그 자체가 하나의 작은 세계로 다른 세계와 구별된다. 완전히 빠져든 사람이 있다면 그것이 세상의 중심이다. 그리고 이런 중심은 도처에 있다. 영원하지는 않더라도 하위문화의 에너지는 쉽게 사라지지 않는다. 또한 이 에너지가 없다면 변화는 일어나지 않는다. 에너지 변화를 수반하는 몰입은 드문 일이 아니다. 사람들은 한때 문학에 열중한 적도 있었으며, 음악에 열광하거나 정치나 전쟁에 열광한 적도 있었다. 팝 문화나 TV나 영화에 빠져든 적도 있으며 모든 문화 영역은 이런 에너지로 넘친다. 글을 쓰다 보니 다른 문화와의 유사점만을 부각했지만 그것은 사실이다. 언제나 일어나는 현상인 것이다!

그 중에서 필자는 컴퓨터의 문화 원동력이었던 해커에 대해 이야기하고 있는 것이다. 우리가 과거의 해커들에 대해 어떤 식으로 규정하느냐는 바로 같은 업종에서 일하거나 관심을 갖는 우리의 일에 대한 새로운 해석을 필요로 한다(독자들은 이와 비슷한 말을 다른 역사책에서 이미 많이 들었을 것이다).

** 하드웨어와 교감하다
초창기 컴퓨터는 많은 개량이 필요한 것이었다. 제작회사들이 아무리 멋있게 포장을 해도 당시 기계들은 요즘의 작은 IC 하나만도 못한 능력을 가졌다. 1초에 10만 번 덧셈을 할 수 있는 정도였다. 컴퓨터 하드웨어는 별것이 없었다.

하드웨어의 예를 들기 위해 오디오 앰프의 예를 들어보자. 오래전에 오디오라는 것은 별것이 없었다. 진공관 몇 개로 만든 앰프를 가지고 오디오광들은 신비스러운 음악의 세계로 빠져들었다. 당시의 명기라는 설계들도 회로로 보자면 오늘날의 기준에서 초라하기 그지없다. 주요 음원인 LP 판에서 나올 수 있는 소리의 질도 제한적인 것이었다. 그러나 많은 사람들은 빈약한 하드웨어의 경계를 넘어 소리에 빠져들었다. LP 판에서 나오는 잡음도 큰 방해가 되지는 못했다. 판을 너무 열심히 듣다 보면 골이 닳아버려 LP 판의 물리적인 수명이 다하곤 했다.

[[https://user-images.githubusercontent.com/25581533/73677552-dc986f80-46f9-11ea-8810-ccde7b5b4fea.png]]

*그림 1. 하나의 진공관으로 만들어진 앰프.* 사실상 트랜지스터 1개에 해당한다.

그러나 적어도 최소한도의 구현은 있어야 했다. 매우 초기에는 오디오를 듣는 사람과 만들고 개선하는 사람을 구분하기 힘들었다. 초기 오디오 설계와 구현은 많은 에너지의 집중을 필요로 했다. 하지만 최소한도의 세팅이 이루어지고 사람들이 이것을 좋아하기만 한다면 그 관심과 집중은 많은 변화를 만들어낼 수 있었다. 사람들은 수백 개의 음반을 듣고 수집하기도 하며 음반을 평가하고 관리하는 일도 큰 사업이라는 사실을 알게 된다. 레코드 시장도 커져갔다.

컴퓨터 역시 마찬가지였다. 일단 최소한도의 것들이 만들어지자 컴퓨터에 빠져드는 사람들이 늘기 시작했다. 당시 자료들을 검토하고 있자면 놀랄만한 일들이 한두 가지가 아니다. 1950년대는 말할 것도 없고 1960년대에 들어와 트랜지스터를 이용한 컴퓨터가 나오기 시작했을 때의 하드웨어도 빈약하기는 마찬가지였다. 예를 들면 플립플롭 회로 하나가 작은 책자 정도 크기였는데 레지스터의 1비트에 해당했다. 그러니까 책꽂이 하나가 1워드가 되는 셈이다. 커다란 컨트롤 패널이 보여주는 정보는 요즘의 디버거 한 줄의 정보에도 미치지 못할 때가 많았다. 프로세서 유닛의 명령은 다이오드와 배선으로 하드와이어 연결이 이루어져 있었다. 이 정도의 기계도 줄을 서야 사용할 수 있었다. 레지스터와 컨트롤 유닛, ALU 같은 것은 구조가 밖에서도 훤히 보였다.

[[https://user-images.githubusercontent.com/25581533/73677836-74965900-46fa-11ea-8a28-a9bba7a1fb61.png]]

*그림 2. 초창기 PDP-1의 모듈의 일부.*  이 모듈은 NOT의 기능을 수행하고 이런 모듈들을 모아 PDP-1이 만들어졌다.

[[https://user-images.githubusercontent.com/25581533/73677564-e15d2380-46f9-11ea-9dd6-fae0ec56c2e6.png]]

*그림 3. 몇 년이 지나자 TTL IC 한 개가 모듈의 기능을 대체할 수 있게 되었다.*

교감하고 집중하는 것이 사실상 프로젝트의 성공과 실패를 좌우하는 일이다. 많은 프로젝트들은 사람들의 관심과 집중을 받지 못해 실패했다. 반대로 아주 빈약한 하드웨어라도 사람들의 힘과 정신력의 집중은 대단한 결과를 만들어낸다. 개발 프로젝트의 대상은 사람들과 교감한다. 개인적인 생각이지만 필자는 사람들의 머릿속 코딩이 기계의 코딩에 우선한다고 생각한다. 초창기에는 더 중요하다. 몇 년을 우회할 발전이 며칠 만에 해결되는 수도 있다. 그래서 우선은 사람들을 코딩되어야 한다.

어떤 일을 너무 좋아하는 사람들이 나타나면 일은 빠르게 진행된다. 컴퓨터가 이들에게는 세상의 중심이었다. 오늘날의 컴퓨터에 비하면 빈약한 하드웨어와 소프트웨어였으나 이것으로도 교감할 수 있었다. 하드웨어는 언제나 더 많은 개선을 필요로 했고 최고의 효율을 발휘해도 언제나 연산능력과 메모리는 부족했다.

초창기 컴퓨터라는 것은 비싼 장비였기 때문에 사용에 제약이 가해지기는 했으나 컴퓨터 제작회사의 엔지니어나 그것을 사용하는 해커들은 실험적으로 많은 해킹을 했다. 기술적으로 특별히 감출만한 것들도 없었다. 나중에 그 기계 사용자들이 회사에 입사해 새로운 컴퓨터들을 만들어 내기도 했다. 필자는 과연 당시 사용자들이 새로운 시도를 중지하고 제작회사에서 하라고 정한 일들만 하는 것이 옳았는지 아니면 왕성한 실험정신을 발휘한 것이 맞았는지에 대해 생각해 보아야 한다고 믿는다(물론 필자의 생각은 이단적일 수 있으며 생각하기에 따라 맞을 수도 틀릴 수도 있다).

이 정도의 하드웨어에서 지난번에 설명한 것과 같은 리스프 인터프리터가 구현되었다. 초기에는 리스프에 제한이 너무 많았다. 리스프가 상당히 개선된 것은 코톡이라는 해커가 설계한 컴퓨터에 그린블러트의 MacLISP가 구현되고부터다. 코톡은 나중에 DEC로 가서 PDP-6의 주 설계자가 되고 PDP-6은 나중에 PDP-10이 된다.

1970년대에 이미 36비트 컴퓨터가 존재했다. 다시 몇 년의 세월이 지나자 초기 해커들은 몇 명을 제외하고는 대부분 자리를 옮겼다. 컴퓨터가 세상의 중심이었던 사람들 역시 체력과 집중력이 약화되는 것을 몸으로 느꼈을 뿐만 아니라 사회적, 경제적인 제약으로부터 자유롭지 못했다. 초기 리스프 해커들의 전성기는 10년 정도 지속되었다.

[[https://user-images.githubusercontent.com/25581533/73677989-c0e19900-46fa-11ea-8ab2-d7212015af43.png]]

*그림 4. PDP-1(www.computerhistory.org 의 사진에서)*

** 람다 계산법(Lambda Calculus)
열정과 집중이 중요하다는 이야기를 너무 길게 한 것 같다. 이제 다시 리스프 이야기로 돌아오자.

리스프가 람다 표기법을 채택한 것은 지난번에 설명했다. 리스프 프로그램에 대해 자세히 설명하지도 않고 리스프 인터프리터를 만드는 이야기를 진행하였으니 황당하기는 하지만 실제로 리스프는 그렇게 갑자기 세상에 나타난 것이다.

리스프는 함수를 람다 표기법으로 나타낸다. 람다 표기법은 특별히 수나 기호를 구분하지 않는다. 람다 표기법은 조금 생소한 것이라 설명이 필요하다. 람다 계산법은 치환을 다루는 계산법이다. 전반적인 내용이나 배경이 [[http://en.wikipedia.org/wiki/Lambda_calculus][위키백과]]에 상당히 잘 정리되어 있다. 필자는 람다 계산법을 설명하기 위해 ‘[[https://web.archive.org/web/20150711203437/https://www.jetcafe.org/jim/lambda.htmll][An Introduction to Lambda Calculus and Scheme]]’에 나오는 예제를 그대로 몇 개 인용해 보았다.

함수는 입력을 받는 부분과 결과를 내는 부분이 있다. 이제 우리가 어떤 대상에 초콜릿을 씌우는 함수를 갖고 있다고 생각하고 다음과 같은 것을 생각해 보자.
#+BEGIN_SRC
peanuts ->     chocolate-covered peanuts
raisins ->     chocolate-covered raisins
ants    ->     chocolate-covered ants
#+END_SRC

이것을 람다 계산법을 사용하여 표현하면 다음과 같다.
#+BEGIN_SRC
Lx.chocolate-covered x
#+END_SRC

여기서 =L= 은 람다(λ)를 나타낸다. 함수에 인자를 대입하는 것을 다음과 같이 표시한다.
#+BEGIN_SRC
(Lx.chocolate-covered x)peanuts -> chocolate-covered peanuts
#+END_SRC

람다 계산법에 따르면 람다식에 어떤 인자를 적용한 결과가 또 하나의 함수일 수도 있다. 초콜릿이 아니라 캐러멜을 포장할 수도 있는 것이다. 이를테면 아래와 같은 람다식을 만들 수 있다. 이 식은 =y= 로 싸인 =x= 를 만드는 것이다.
#+BEGIN_SRC
Ly.Lx.y-covered x
#+END_SRC

이제 캐러멜을 덮는 함수를 만들어낼 수 있다. 식은 =y= 인자로 캐러멜을 받았다.
#+BEGIN_SRC
(Ly.Lx.y-covered x)caramel -> Lx.caramel-covered x
#+END_SRC

그리고 이 함수는 다시 땅콩을 덮도록 만들 수 있다. =x= 인자로 =peanuts= 를 받았다.
#+BEGIN_SRC
(Lx.caramel-covered x)peanuts -> caramel-covered peanuts
#+END_SRC

함수의 인자가 반드시 숫자일 필요는 없다. 람다 계산법에서 함수는 다른 함수의 인자가 될 수도 있다. 지난번의 간단한 인터프리터에서도 함수를 다른 함수의 입력으로 사용할 수 있었다. 아래 식에서 =f= 인자는 함수다.
#+BEGIN_SRC
Lf.(f)ants
#+END_SRC

그래서 초콜릿을 포장하는 함수를 =ant= 에 적용할 수 있다. =(apply-to-ants)= 를 잘 살펴보면 단순한 치환이 이루어지는 것을 알 수 있다. =()= 의 주변을 잘 살펴보라. =f= 는 =Lx.chocolate-covered x= 로 대체되었다. 그리고 =x= 에는 =ants= 가 적용되었다.
#+BEGIN_SRC
(Lf.(f)ants)Lx.chocolate-covered x
-> (Lx.chocolate-covered x)ants
-> chocolate-covered ants
#+END_SRC

함수가 한 람다식을 적용한 결과로 만들어질 수 있다는 것은 대단한 일로 많은 가능성을 갖고 있다. 이런 것을 클로저(closure)라고 부르기도 하며 리스프나 스킴(scheme)에서 고차함수를 만드는 바탕이 되었다.

자세한 증명은 람다식을 다루는 문헌들을 찾아보기로 하고 람다 계산법이 왜 일반적인 컴퓨팅의 원리로 변할 수 있었는지를 생각해 보자. 사실 컴퓨터는 구현 이전부터 만들어질 수 있는 방법이 있었다. 그 중 하나는 람다 계산법을 통해서다. 전기 스위치를 사용하건 다른 기계적인 무엇을 사용하건 만들어질 수 있었다. 구현 논리는 이미 수학적으로 존재했다. 우선 조건식을 람다함수로 만들어낼 수 있다. 이를테면 참과 거짓을 다음과 같이 만들어낼 수 있다.
#+BEGIN_SRC
true  = Lx.Ly.x
false = Lx.Ly.y
if-then-else = La.Lb.Lc.((a)b)c
#+END_SRC

매우 생소하기는 하지만 논리식을 람다 함수로 표시해본 것이다. 몇 개의 치환을 거쳐 람다 함수는 조건식을 정확히 계산한다. 아래의 식은 =if-then-else= 가 참이면 =apple= 을, 거짓이면 =banana= 를 돌려주도록 되어 있다. 미리 =false= 를 적용한 것이라 =banana= 를 돌려준다.
#+BEGIN_SRC scheme
(((if-then-else)false)apple)banana
-> (((La.Lb.Lc.((a)b)c)Lx.Ly.y)apple)banana
-> ((Lb.Lc.((Lx.Ly.y)b)c)apple)banana
-> (Lc.((Lx.Ly.y)apple)c)banana
-> ((Lx.Ly.y)apple)banana
-> (Ly.y)banana
-> banana
#+END_SRC

간단한 정리 몇 개를 적용한 것치고는 많은 일을 할 수 있는 것 같다는 생각이 들지 않는가? 아무튼 앞서의 초콜릿과 캐러멜을 치환하는 식과 =peanuts=, =raisins=, =ants= 를 치환하는 방법을 그대로 적용한 것이다. 종이와 연필로 계산해볼 수 있다. 지난번의 =cons= 와 =car=, =cdr= 도 람다식으로 표현할 수 있다.
#+BEGIN_SRC
cons = La.Lb.Lc.((c)a)b
car = Lx.(x)true
cdr = Lx.(x)false
#+END_SRC

이런 방법으로 생각하는 =cons=, =car=, =cdr= 의 정의가 나름대로 중요한 내용이라 실제로 SICP의 비디오 강의 5b에서는 중요한 개념으로 떠오른다. 강의에 나오는 스킴 식에서는 다음과 같이 정의했다.
#+BEGIN_SRC scheme
(define (cons x y) (lambda(m) (m x y)))
(define (car x) (x (lambda (a d ) a))
(define (cdr x) (x (lambda (a d ) d))
#+END_SRC

이 식을 실제로 수행하면 다음과 같다.
#+BEGIN_SRC scheme
(car (cons 35 47))
-> (car (lambda (m)(m 35 47)))
-> ((lambda(m)(m 35 47)) (lambda(a d) a))
-> ((lambda (a d) a) 35 47)
-> 35
#+END_SRC

별것 아닌 것처럼 보이는 내용이겠지만 위 정의를 조금 더 변형하면 사이드 이펙트(side-effect)를 만들어낼 수도 있고 함수형 언어에서 덮어쓰기(assignment)의 메커니즘을 만들어낼 수도 있다. 재귀(recursion) 역시 람다식을 이용해 만들어낼 수 있다. Y 컴비네이터라고 부르는 것인데 리스프에서는 label을 이용한 다른 방법으로 구현했다.

리스프라는 언어는 이런 람다 계산법을 적용하는 하나의 이론적인 기계 그 자체이며(지난번에 설명한 간단한 evaluator 그 자체가 A4 용지 한 페이지 정도의 식이다) 리스트로 되어있는 다른 리스프 식을 읽어 이들을 치환하여 계산을 하고 경우에 따라 수식이나 새로운 함수 자체를 답으로 되돌린다.

** Paradigms of Artificial Intelligence Programming
초창기 해커들이 관여하던 몇 가지 문제들을 정리한 책이 있다. 리스프가 개발되고 문제의 표현을 위해 사용되던 곳이 인공지능(AI) 분야였기 때문에 당연히 리스프에는 좋은 예제가 많았다.

[[https://user-images.githubusercontent.com/25581533/73679135-2898e380-46fd-11ea-9b81-4113b56e3f94.png]]
피터 노빅(Perer Norvig, http://Norvig.com )이 쓴 책 중에 『Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp』라는 유명한 책이 있다. 첫 회에 소개한 SICP보다 더 어려운 수준의 책(하드코어에 속한다고 하는 사람도 있다)이지만 리스프로 어떻게 인공지능 문제들을 접근했는지에 대한 좋은 자료다. 책의 2부는 초기 AI 프로그램을 다루고 분석하고 있다. 이를테면 GPS(General Problem Solver), ELIZA, 수학적 기호처리 같은 것들을 다룬다.

책을 사볼 필요는 없겠지만 [[https://github.com/norvig/paip-lisp][Paradigms of Artificial Intelligence Programming]]에서 ‘Excerpts from the preface, including why Lisp?’ 같은 글들을 읽어 보기 바란다. 어려운 내용도 아니며 좋은 생각거리를 제공할 것이다. 그 외에도 좋은 글들이 꽤 많다.
